#!/usr/bin/python

#Audio Tools, a module and set of tools for manipulating audio data
#Copyright (C) 2007-2011  Brian Langenberger

#This program is free software; you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation; either version 2 of the License, or
#(at your option) any later version.

#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with this program; if not, write to the Free Software
#Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA


import sys
import audiotools
import os.path
import gettext

gettext.install("audiotools", unicode=True)


#--replace-metadata, no XMCD file given
#completely wipe out existing metadata
#and replace with tags given on command-line
def blank_metadata(track, xmcd):
    return audiotools.MetaData()


#no --replace-metadata, no XMCD file given
#use metadata from existing tracks as base
#and merge with tags given on command-line
def track_metadata(track, xmcd):
    return track.get_metadata()


#--replace-metadata, XMCD file given
#completely wipe out existing metadata
#and replace with command-line tags merged with XMCD metadata
def xmcd_metadata(track, xmcd):
    metadata = xmcd.get(track.track_number(), None)
    if (metadata is not None):
        return metadata
    elif (len(xmcd) > 0):
        return xmcd.metadata()
    else:
        return None


#no --replace metadata, XMCD file given
#replace with command-line tags merged with XMCD metadata
#*and* existing metadata
def xmcd_track_metadata(track, xmcd):
    track_metadata = track.get_metadata()

    if (track_metadata is not None):
        xmcd_md = track_metadata.__class__.converted(
            xmcd_metadata(track, xmcd))
    elif (len(xmcd) > 0):
        xmcd_md = xmcd.get(track.track_number(), None)
        if (xmcd_md is None):
            xmcd_md = xmcd.metadata()
    else:
        xmcd_md = None

    if (xmcd_md is not None):
        xmcd_md.merge(track_metadata)

    return xmcd_md


#--replace-metadata
def replace_cuesheet(track, import_cuesheet):
    return import_cuesheet


#no --replace-metadata
def noreplace_cuesheet(track, import_cuesheet):
    if (import_cuesheet is None):
        return track.get_cuesheet()
    else:
        return import_cuesheet


#tries to return a populated Image object of the appropriate type
#raises InvalidImage if something goes wrong during opening or parsing
def get_raw_image(filename, type):
    try:
        f = open(filename, 'rb')
        data = f.read()
        f.close()

        return audiotools.Image.new(data, u'', type)
    except IOError:
        raise audiotools.InvalidImage(_(u"Unable to open file"))


def get_thumbnailed_image(filename, type):
    image = get_raw_image(filename, type)
    if ((image.width > audiotools.THUMBNAIL_SIZE) or
        (image.height > audiotools.THUMBNAIL_SIZE)):
        return image.thumbnail(audiotools.THUMBNAIL_SIZE,
                               audiotools.THUMBNAIL_SIZE,
                               audiotools.THUMBNAIL_FORMAT)
    else:
        return image


#given a comment filename
#returns the comment as a unicode string
#or exits with an error if the file cannot be read
#or is not UTF-8 text
def read_comment(filename, messenger):
    try:
        f = open(filename, 'rb')
        data = f.read().decode('utf-8', 'replace')
        f.close()

        if (((data.count(u"\uFFFD") * 100) / len(data)) >= 10):
            messenger.error(
                _(u"Comment file \"%s\" does not appear to be UTF-8 text") %
                (messenger.filename(filename)))
            sys.exit(1)
        else:
            return data
    except IOError:
        messenger.error(_(u"Unable to open comment file \"%s\"") % \
                            (messenger.filename(filename)))
        sys.exit(1)


if (__name__ == '__main__'):
    parser = audiotools.OptionParser(
        usage=_(u"%prog [options] [-x XMCD file] <track 1> [track 2] ..."),
        version="Python Audio Tools %s" % (audiotools.VERSION))

    text_group = audiotools.OptionGroup(parser, _(u"Text Options"))

    for (option, destination, helptext) in [
        ('--name', 'track_name', _(u"the name of the track")),
        ('--artist', 'artist_name', _(u'the name of the artist')),
        ('--performer', 'performer_name', _(u'the name of the performer')),
        ('--composer', 'composer_name', _(u'the name of the composer')),
        ('--conductor', 'conductor_name', _(u'the name of the conductor')),
        ('--album', 'album_name', _(u'the name of the album')),
        ('--catalog', 'catalog', _(u'the catalog number of the album')),
        ('--number', 'track_number',
         _(u"the number of the track in the album")),
        ('--track-total', 'track_total',
         _(u"the total number of tracks in the album")),
        ('--album-number', 'album_number',
         _(u'the number of the album in a set of albums')),
        ('--album-total', 'album_total',
         _(u"the total number of albums in a set of albums")),
        ('--ISRC', 'ISRC', _(u'the ISRC of the track')),
        ('--publisher', 'publisher', _(u'the publisher of the album')),
        ('--media-type', 'media_type',
         _(u'the media type of the album, such as "CD"')),
        ('--year', 'year', _(u'the year of release')),
        ('--date', 'date', _(u'the date of recording')),
        ('--copyright', 'copyright', _(u'copyright information')),
        ('--comment', 'comment', _(u'a text comment'))]:
        if (destination not in audiotools.MetaData.__INTEGER_FIELDS__):
            text_group.add_option(option,
                                  action='store',
                                  type='string',
                                  dest=destination,
                                  help=helptext)
        else:
            text_group.add_option(option,
                                  action='store',
                                  type='int',
                                  dest=destination,
                                  help=helptext)

    text_group.add_option(
        '--comment-file',
        action='store',
        type='string',
        dest='comment_file',
        metavar='FILENAME',
        help=_(u'a file containing comment text'))

    parser.add_option_group(text_group)

    parser.add_option(
        '-r', '--replace',
        action='store_true',
        default=False,
        dest='replace',
        help=_(u'completely replace all metadata'))

    parser.add_option(
        '-x', '--xmcd',
        action='store',
        type='string',
        dest='xmcd',
        metavar='FILENAME',
        help=_(u'FreeDB XMCD file or MusicBrainz XML file'))

    parser.add_option(
        '--cue',
        action='store',
        type='string',
        dest='cue',
        metavar='FILENAME',
        help=_(u'a cuesheet to import or get audio metadata from'))

    img_group = audiotools.OptionGroup(parser, _(u"Image Options"))

    img_group.add_option(
        '--remove-images',
        action='store_true',
        default=False,
        dest='remove_images',
        help=_(u'remove existing images prior to adding new ones'))

    for (option, destination, helptext) in [
        ('--front-cover', 'front_cover',
         _(u'an image file of the front cover')),
        ('--back-cover', 'back_cover',
         _(u'an image file of the back cover')),
        ('--leaflet', 'leaflet', _(u'an image file of a leaflet page')),
        ('--media', 'media', _(u'an image file of the media')),
        ('--other-image', 'other_image',
         _(u'an image file related to the track'))]:
        img_group.add_option(
            option,
            action='append',
            type='string',
            dest=destination,
            metavar='FILENAME',
            help=helptext)

    img_group.add_option(
        '-T', '--thumbnail',
        action='store_true',
        default=False,
        dest='thumbnail',
        help=_(u'convert given images to smaller thumbnails ' +
               u'before adding'))

    parser.add_option_group(img_group)

    remove_group = audiotools.OptionGroup(parser, _(u"Removal Options"))

    for (option, destination, helptext) in [
        ('--remove-name', 'remove_track_name', _(u'remove track name')),
        ('--remove-artist', 'remove_artist_name', _(u'remove track artist')),
        ('--remove-performer', 'remove_performer_name',
         _(u'remove track performer')),
        ('--remove-composer', 'remove_composer_name',
         _(u'remove track composer')),
        ('--remove-conductor', 'remove_conductor_name',
         _(u'remove track conductor')),
        ('--remove-album', 'remove_album_name', _(u'remove album name')),
        ('--remove-catalog', 'remove_catalog', _(u'remove catalog number')),
        ('--remove-number', 'remove_track_number',
         _(u'remove track number')),
        ('--remove-track-total', 'remove_track_total',
         _(u'remove total number of tracks')),
        ('--remove-album-number', 'remove_album_number',
         _(u'remove album number')),
        ('--remove-album-total', 'remove_album_total',
         _(u'remove total number of albums')),
        ('--remove-ISRC', 'remove_ISRC', _(u'remove ISRC')),
        ('--remove-publisher', 'remove_publisher', _(u'remove publisher')),
        ('--remove-media-type', 'remove_media_type',
         _(u'remove album\'s media type')),
        ('--remove-year', 'remove_year', _(u'remove release year')),
        ('--remove-date', 'remove_date', _(u'remove recording date')),
        ('--remove-copyright', 'remove_copyright',
         _(u'remove copyright information')),
        ('--remove-comment', 'remove_comment', _(u'remove text comment'))]:
        remove_group.add_option(
            option,
            action='store_true',
            default=False,
            dest=destination,
            help=helptext)

    parser.add_option_group(remove_group)

    parser.add_option(
        '--replay-gain',
        action='store_true',
        default=False,
        dest='add_replay_gain',
        help=_(u'add ReplayGain metadata to track(s)'))

    parser.add_option(
        '-V', '--verbose',
        action='store',
        dest='verbosity',
        choices=audiotools.VERBOSITY_LEVELS,
        default=audiotools.DEFAULT_VERBOSITY,
        help=_(u'the verbosity level to execute at'))

    (options, args) = parser.parse_args()
    msg = audiotools.Messenger("tracktag", options)

    audiofiles = audiotools.open_files(args, messenger=msg)

    if (options.xmcd is not None):
        try:
            xmcd = audiotools.read_metadata_file(options.xmcd)
        except audiotools.MetaDataFileException, err:
            msg.error(unicode(err))
            sys.exit(1)
    else:
        xmcd = None

    isrcs = {}
    import_cuesheet = None
    if (options.cue is not None):
        try:
            cuesheet = audiotools.read_sheet(options.cue)

            #if there's a single audio file
            #and the cuesheet is sized to fit that file
            #attempt to embed the cuesheet in the file
            if ((len(audiofiles) == 1) and
                (list(cuesheet.pcm_lengths(
                            audiofiles[0].total_frames()))[-1] > 0)):
                import_cuesheet = cuesheet
            else:
                #otherwise, treat the cuesheet is a source of ISRC data
                isrcs = dict([(k, v.decode('ascii', 'replace'))
                              for (k, v) in
                              cuesheet.ISRCs().items()])
        except audiotools.SheetException, err:
            msg.error(unicode(err))
            sys.exit(1)

    if (options.replace):
        if (xmcd is None):
            metadata_function = blank_metadata
        else:
            metadata_function = xmcd_metadata
        cuesheet_function = replace_cuesheet
    else:
        if (xmcd is None):
            metadata_function = track_metadata
        else:
            metadata_function = xmcd_track_metadata
        cuesheet_function = noreplace_cuesheet

    if (options.thumbnail):
        if (not audiotools.can_thumbnail()):
            msg.error(_(u"Unable to generate thumbnails"))
            msg.info(
                _(u"Please install the Python Imaging Library"))
            msg.info(
                _(u"available at http://www.pythonware.com/products/pil/"))
            msg.info(_(u"to enable image resizing"))
            sys.exit(1)

        if (audiotools.THUMBNAIL_FORMAT.upper() not in
            audiotools.thumbnail_formats()):
            msg.error(_(u"Unsupported thumbnail format \"%s\"") %
                      (audiotools.THUMBNAIL_FORMAT))
            msg.info(_(u"Available formats are: %s") %
                     (", ".join(audiotools.thumbnail_formats())))
            sys.exit(1)

        get_image = get_thumbnailed_image
    else:
        get_image = get_raw_image

    for file in audiofiles:
        #our command-line built MetaData block,
        #which takes precedence over the others
        metadata = audiotools.MetaData()

        if (file.track_number() in isrcs.keys()):
            metadata.ISRC = isrcs[file.track_number()]

        for field in ('track_name',
                      'artist_name',
                      'performer_name',
                      'composer_name',
                      'conductor_name',
                      'album_name',
                      'catalog',
                      'track_number',
                      'track_total',
                      'album_number',
                      'album_total',
                      'ISRC',
                      'publisher',
                      'media_type',
                      'year',
                      'date',
                      'copyright',
                      'comment'):
            if (getattr(options, field) is not None):
                attr = getattr(options, field)
                if (isinstance(attr, str)):
                    attr = attr.decode(audiotools.IO_ENCODING,
                                       'replace')
                setattr(metadata, field, attr)

        if (options.comment_file is not None):
            metadata.comment = read_comment(options.comment_file, msg)

        #our MetaData block built from the existing file
        #and any given XMCD file
        track_metadata = metadata_function(file, xmcd)

        #our cuesheet block built from any given cuesheet file
        track_cuesheet = cuesheet_function(file, import_cuesheet)

        #transfer images from old MetaData block
        #and from command-line options
        try:
            if (metadata.supports_images()):
                if (track_metadata is not None):
                    if (not options.remove_images):
                        for i in track_metadata.images():
                            metadata.add_image(i)
                    else:
                        for i in track_metadata.images():
                            track_metadata.delete_image(i)

                if (options.front_cover is not None):
                    for path in options.front_cover:
                        metadata.add_image(get_image(path, 0))

                if (options.leaflet is not None):
                    for path in options.leaflet:
                        metadata.add_image(get_image(path, 2))

                if (options.back_cover is not None):
                    for path in options.back_cover:
                        metadata.add_image(get_image(path, 1))

                if (options.media is not None):
                    for path in options.media:
                        metadata.add_image(get_image(path, 3))

                if (options.other_image is not None):
                    for path in options.other_image:
                        metadata.add_image(get_image(path, 4))
        except audiotools.InvalidImage, err:
            msg.error(_(u"%(filename)s: %(message)s") % \
                          {"filename": msg.filename(file.filename),
                           "message": unicode(err)})
            sys.exit(1)

        if (track_metadata is not None):
            #remove attributes from old MetaData
            for field in ('track_name',
                          'artist_name',
                          'performer_name',
                          'composer_name',
                          'conductor_name',
                          'album_name',
                          'catalog',
                          'track_number',
                          'track_total',
                          'album_number',
                          'album_total',
                          'ISRC',
                          'publisher',
                          'media_type',
                          'year',
                          'date',
                          'copyright',
                          'comment'):
                if (getattr(options, 'remove_' + field)):
                    delattr(track_metadata, field)

            metadata = track_metadata.__class__.converted(metadata)
            metadata.merge(track_metadata)

        try:
            file.set_metadata(metadata)
            if (track_cuesheet is not None):
                file.set_cuesheet(track_cuesheet)
        except IOError:
            msg.error(_(u"Unable to modify \"%s\"") % \
                          msg.filename(file.filename))
            sys.exit(1)

    #we're assuming all tracks are the same type
    #add_replay_gain should check if they are not
    if (options.add_replay_gain and
        (len(audiofiles) > 0) and
        (audiofiles[0].can_add_replay_gain())):

        rg_progress = audiotools.ReplayGainProgressDisplay(
            msg, audiofiles[0].lossless_replay_gain())
        rg_progress.initial_message()
        try:
            #separate encoded files by album_name and album_number
            for album in audiotools.group_tracks(audiofiles):
                #add ReplayGain to groups of files
                #belonging to the same album

                album[0].add_replay_gain([a.filename for a in album],
                                         rg_progress.update)
        except ValueError, err:
            rg_progress.clear()
            msg.error(unicode(err))
            sys.exit(1)
        rg_progress.final_message()
